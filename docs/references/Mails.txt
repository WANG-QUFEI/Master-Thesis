$- Sun 24/01/2021 15:24

I think we can start the work now (the proposal is fine for me).

 The first thing will be to write a type-checker for a system with a type of all types
as simple as possible in which one can check Hurkens paradox.

 The most complex thing will be probably to write a parser and printer.

 I suggest the following syntax (it is important that the syntax is as uniform as possible)

 A, M ::=    DM |  E
 F ::=   x | U | (M)
 E ::= F | E F
 D ::= [x : A = M] | [x : A]

 I don’t think there is a problem to use the same syntax for lambda and pi.

 So a term is a list (maybe empty) of declarations followed by a (nonempty) list 
of atomic expressions, where an atomic expressions is a variable the constant U or (M)
where M is a term.

 You define then in Haskell a corresponding type of  -concrete- expressions

 You also define a type of -abstract- expressions

 An abstract expression is describe by the data type
 
 Exp ::=   U | Ref nat |  Abs Exp Exp | Let Exp Exp Exp | App Exp Exp 

 You then write a type-checker for this, following the description in miniTT.

 The goal is to have something working for Hurkens paradox within one week.

 The next step will be to add some locking/unlocking annotation.

 Thierry


$- Fri 12/02/2021 16:25

Here is a file with the syntax I would like you to use (I will complete the file later)

Please write the concrete and abstract syntax in Haskell as well for the next meeting

 Thierry

——————

Pow : * -> *
Pow = [X : *] X -> *

T : * -> *
T = [X : *] Pow (Pow X)

funT : [X : *][Y : *] (X -> Y) -> T X -> T Y
funT = [X : *][Y : *][f : X -> Y][t : T x][g : Y -> *] t ([x : X] g (f x))

⊥ = [X : *] X

¬ : * -> *
¬ X = X -> ⊥

U : *
U = [X : *] (T X -> X) -> X

tau : T U -> U
tau = [t : T U][X : *][f : T X -> X] f ([g : X -> *] t ([z : U] g (z X f)))

sigma : U -> T U
sigma = [z : U]z (T U) ([t : T (T U)][g : U -> *] t ([x : T U] g (tau x)))

Q : T U
Q = [p : U -> *][z : U] sigma z p -> p z

B : Pow U
B = [z : U] ¬ ([p : Pow U] sigma z p -> p (tau (sigma z)))

**************************************************************************************
{-# OPTIONS --type-in-type #-}

module loop2 where

Pow : Set -> Set
Pow X = X -> Set

T : Set -> Set
T X = Pow (Pow X)

funT : (X Y : Set) -> (X -> Y) -> T X -> T Y
funT X Y f t g = t (λ x -> g (f x))

postulate ⊥ : Set
postulate foo : ⊥ -> ⊥
-- ⊥ = (X : Set) -> X

¬ : Set -> Set
¬ X = X -> ⊥

U : Set
U = (X : Set) -> (T X -> X) -> X

tau : T U -> U
tau t X f = f (λ g -> t (λ z -> g (z X f)))


sigma : U -> T U
sigma z = z (T U) (λ t g -> t (λ x -> g (tau x)))


Q : T U
Q p = (z : U) -> sigma z p -> p z

B : Pow U
B z = ¬ ((p : Pow U) -> sigma z p -> p (tau (sigma z)))

C : U
C = tau Q

lem1 : Q B 
lem1 z k l = l B k (λ p -> l (λ z -> p (tau (sigma z)))) 

A : Set
A = (p : Pow U) -> Q p -> p C

lem2 : ¬ A
lem2 h = h B lem1 (λ p -> h  (λ z -> p (tau (sigma z))))

lem3 : A
lem3 p h = h C (λ x -> h (tau (sigma x)))

loop : ⊥
loop = lem2 lem3

$- Tuesday, 2/3/2021

 So you should follow the type-checker from

 http://www.cse.chalmers.se/~coquand/mTT10.pdf

page 4.

 A difference however is that you work with -typed- abstraction and that we try
to use the same binder from dependent product and abstraction.

 So the abstract syntax should be

 AExp =    Ref Int | App AExp AExp  | Lam AExp AExp | Where AExp Def

 Def = Def AExp AExp


 You should write a function   Exp -> AExp  
from -concrete- syntax (produced by the parser) to -abstract- syntax (used for evaluation
and type-checking).

 This function has an accumulator which is a list of declared identifier.

 For implication you can use a dummy identifier  “”.

 You define also a type of environment and values

 Env =  Nil | Push Env Val | Def Env Def

 Val =  Var Int | VApp Val Val | VLam Val Val |  Clos AExp Env

 with the evaluation rule given page 3

 You can then use the type-checking rules on page 4.

 Thierry

---------------------------------------------------------------------------
For instance, we have -impiication- or arrow in the -concrete- syntax
but we don’t have it in the -abstract- syntax.

 To use de Bruijn index takes a little time to get used to, but it becomes clearer
in the long range, and it is good in any case to check -scope- of identifier
early on (that any identifier that is used has been declared somewhere, which is
what you have to do for the translation identifier -> de Bruijn index).

---------------------------------------------------------------------------
You can also look at

 http://www.cse.chalmers.se/~coquand/MTT.hs

where I wrote a type-checker and evaluator

 There are some differences:

 -use of untyped lambda
 -the definitions are more complex (mutual definitions)
 -I mixed the type of abstract syntax and values in one data type

but this may provide some help.

-------------------------------------------------------------------------------------
Wed 24/03/2021 12:11

 Two further functions that would be nice to have are

 defCont :: String -> Cont -> Exp
 defCont x (ConsVar c y a) = if x == y then Var x else defCont x c
 defCont x (ConsDef c y a e) = if x == y then e else defCont x c
 defCont x Nil = Var x

and 

 headRed :: Cont -> Exp -> Val
 headRed c  (Var x) = eval (defCont x) Nil
 headRed c  (App e1 e2) = appVal (headRed c e1) (eval e2 Nil)
 headRed c  e = eval e Nil

and then you can add another interactive command   hRed  e
that type-check e and if e is typed correct does   headRed c e
and then applies the

 readBack :: [String] -> Val -> Exp

function.

-------------------------------------------------------------------------------------
Fri 26/03/2021 11:52

 For the function readBack:    the rough idea is that elements of type Val  are like
virtual expressions that are used during type-checking but themselves cannot be
type-checked.
 For the interactive loop, one needs first to transform a Val to a Exp which can be
evaluated again.   
 So what this function is doing is removing all closures for a Val so that we get
an Exp. In order to do that we need to respect non duplication, hence the list
of names as parameters.
