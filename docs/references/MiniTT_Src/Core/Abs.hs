-- Haskell data types for the abstract syntax.
-- Generated by the BNF converter.

{-# LANGUAGE GeneralizedNewtypeDeriving #-}

module Core.Abs where

import Prelude (Char, Double, Int, Integer, String)
import qualified Prelude as C (Eq, Ord, Show, Read)
import qualified Data.String

newtype Ident = Ident String
  deriving (C.Eq, C.Ord, C.Show, C.Read, Data.String.IsString)

newtype CaseTk = CaseTk ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

newtype DataTk = DataTk ((Int, Int), String)
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Exp
    = ELam Patt Exp
    | ESet
    | EPi Patt Exp Exp
    | ESig Patt Exp Exp
    | EOne
    | Eunit
    | EPair Exp Exp
    | ECon Ident Exp
    | EData DataTk [Summand]
    | ECase CaseTk [Branch]
    | EFst Exp
    | ESnd Exp
    | EApp Exp Exp
    | EVar Ident
    | EVoid
    | EDec Decl Exp
    | EPN
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Decl = Def Patt Exp Exp | Drec Patt Exp Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Patt = PPair Patt Patt | Punit | PVar Ident
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Summand = Summand Ident Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read)

data Branch = Branch Ident Exp
  deriving (C.Eq, C.Ord, C.Show, C.Read)

eArrow :: Exp -> Exp -> Exp
eArrow a b = EPi Punit a b

eTimes :: Exp -> Exp -> Exp
eTimes a b = ESig Punit a b

