\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{parskip}
\setlength{\parskip}{10pt}
\usepackage{array}
\usepackage{amsthm}
\usepackage{multirow}
\usepackage{ebproof}
\usepackage{stmaryrd}
\usepackage{titlesec}

\theoremstyle{remark}
\newtheorem{example}{Example}[section]
\newtheorem{principle}{Principle}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\begin{document}
\title{Halftime Report}
\author{Qufei Wang}
\maketitle

\tableofcontents

\clearpage

\section{Report Structure}
This report will be structured into three parts: First, a brief summary of the current progress of the project, including what has been done, any deviation from the planning report and what remains to be done; Second, the major part of the report, is a draft of the final report. And the third, adjustment on the time planning for the remaining of the project.

\section{Project Progress}
\subsection{What Has Been Done}
A Haskell implementation of our target language, a command line REPL (read-evaluate-print-loop) tool where a source file of the target language could be loaded and type checked. For the ease of use, we also provide various other commands including those used to experiment with the locking/unlocking mechanism. The first part of the thesis project is to study an extension of lambda calculus with definitions, where constants could be locked/unlocked in the process of evaluation (or reduction). For this part, we could say that we have completed almost all of its work.

\subsection{Deviation From the Time Plan}
This halftime report comes about half month later than what has been scheduled in the planning report. The reasons for the delay are more of psychological than technical. One reason relevant with the project itself is that, I was too obsessed with the idea of getting a bigger picture of how the project might fit into the spectrum of the knowledge of functional programming or logic, rather than getting down to the practical work. Nonetheless, I'm still confident that the remaining work could be finished within the planned time frame, with the shift of my mindset. For this, I would like to thank Thierry for his patience and support.

\subsection{Remaining Work}
The second part of this thesis project is to add a module mechanism with the notion of \emph{segment}. Such a mechanism could be seen as an extension to our target language and the idea of `segment` comes from the system AUTOMATH \cite{de1994survey}, which is conceived and developed by N.G. de Bruijn. The whole picture of AUTOMATH may not be easy to grasp in a short time, but as the example given below shows, we may still be to borrow the idea of `segment` and incorporate it into our language without a fully understanding of the system.
\begin{example}[The notion of `segment`]
  The idea of \emph{segment} is to add a new form of declaration $x = ds\; \textbf{Seg}$, where $x$ is the name of the `segment` or `modules with parameters` and $ds$ a list of declaration (`Seg` is a keyword reserved by the language). Here is an example:
  \[ s = [ A : *,\; id : A \to A = [x : A]\; x ]\; \textbf{Seg} \]
  This is a module which contains one declaration and one definition. The declaration \( A : * \) ($*$ here is the type of all small types, for a detailed description of the syntax, please refer to TODO-REF) acts as a parameter whereas the definition with name $id$ represents the identity function.

  With this segment declaration, if we can form another type \( A0 : * \), we can then write the expression \( (s \; A0) \; . \; id \), which has type $A0 \to A0$ and value $([x : A]\; x) (A = A0)$ (the value here is a closure).
\end{example}

With this example taken in mind, we see what still lacks are extensions to the syntax and type checking rules for our language to accommodate this \emph{module} concept. 

\section{Draft of the Final Report}
\subsection{Abstract}
In this paper, we present a dependently typed language which could be seen as a simplified version of Mini-TT \cite{coquand2009simple}. The main difference between our language and Mini-TT are threefold: First, the syntax of our language is much simpler than that of Mini-TT. Particularly, we use the same syntax for both dependent product ($\Pi x:A.B(x)$) and $\lambda$ abstraction ($\lambda x . M$); Second, we add a locking/unlocking mechanism into our type checking algorithm, from which we find a way to calculate the minimum set of constants that need to be unlocked, such that a constant declaration could be type checked; Third, as an extension to Mini-TT, we build a module system based on the notion of \emph{segments} borrowed from the system AUTOMATH \cite{de1994survey}. The disadvantage of having a limited subset of syntax is its reduced capability in expressiveness (e.g., one can not build data types in our language, which could be expressed as \emph{Labeled Sum} in Mini-TT). However, starting out with a simple syntax allows us to focus on the study of a definition mechanism in dependent type theory, which is the main aim of this thesis project. The outcome of the project is a REPL program implemented in Haskell that provide various commands to load the type check a source file of our language and to experiment with the locking/unlocking mechanism.

\subsection{Terminology}
In order to make clear of the potential ambiguity or unnecessary confusion over the words we choose to use in the following sections, we list here the key terminology and explain their meaning.
\begin{itemize}
  \item \textbf{Declaration:} A \emph{declaration} has either the form $x : A$ or $x : A = B$. The latter is also referred, rather frequently, as a \emph{definition}. Sometimes when we want to make a distinction between these two forms, we use \emph{declaration} specifically to indicate a term of the former form. 
  \item \textbf{Definition:} A \emph{definition} is a term of the form $x : A = B$, meaning that $x$ is an element of type $A$, defined as $B$. Sometimes, when we talk about the components under a specific definition, we also use the word `definition` to refer to part $B$, as it is what $x$ represents.  
  \item \textbf{Constant:} A \emph{constant} is the name or identifier used in a declaration, like the $x$ in $x : A$, $x : A = B$.
  \item \textbf{Variable:} A synonym for the word \emph{constant}. More often, the word \emph{variable} is used to refer the variable bound in a $\lambda$-abstraction, like the variable $x$ in $\lambda x . A$. In most cases, these two words are interchangeable. 
  \item \textbf{Value:} When talk about the components of a definition $x : A = B$, we also use the word `value` to refer to $B$, meaning the value of $x$. Strictly speaking, however, this is inaccurate, since in the syntax of our language, `value` is used to refer to the result of evaluation on an expression. Hence the value of $x$ should be the evaluated form of $B$, not $B$ itself. 
\end{itemize}

\subsection{Introduction}
\subsubsection{Some Background About Dependent Types}
Dependent type theory has lent much of its power to the proof-assistant systems like Coq \cite{huet1997coq}, Lean \cite{de2015lean}, and functional programming languages like Agda \cite{norell2008dependently} and Idris \cite{brady2013idris}, and contributed much to their success. Essentially, \emph{dependent types} are types that depend on \textbf{values} of other types. As a simple example, consider the type that represents vectors of length $n$ comprising of elements of type $A$, which can be expressed as a dependent type $vec\; A\; n$. Readers may easily recall that in imperative languages such as c or java, there are array types which depend on the type of their elements, but no types that depend on values of some other type. More formally, suppose we have defined a function which to an arbitrary object $x$ of type $A$ assigns a type $B(x)$, then the Cartesian product $(\Pi x \in A)B(x)$ is a type, namely the type of functions which take an arbitrary object $x$ of type $A$ into an object of type $B(x)$.

The advantage of having a strong type system built into a programming language is that well typed programs exclude a large portion of run-time errors than those without or with weak type systems. Just as the famous saying puts it “well-type programs cannot ‘go wrong’” [16]. It is in this sense that we say languages equipped with a dependently typed system are guaranteed with the highest level of correctness and precision, which makes them a natural option in building proof-assistant systems.

\subsubsection{Issues with Dependently Typed Systems}
The downside of introducing a dependent type system lies in its difficulties of implementation, one of which is checking the \textbf{convertibility} of terms. More precisely, in any typed system, it is crucial for the type checker to decide whether a type denoted by a term $A$ is equal with another type denoted by a term $B$. In a simple type system where no type polymorphism or dependent type is used, this is done by simply checking the syntactic identity of the symbols of the types. For example, in Java, a primitive type \emph{int} equals only to itself, nothing more, since types in Java are not computable \footnote{Technically speaking, the type of an object in Java can be retrieved by means of the \emph{reflections} and presented in the form of another object, thus subject to computation. But it is not computable on the syntactic level, like being passed as arguments to functions.}, there's no way for other terms in the language to be reduced to the term \emph{int}. In a dependent type system, however, the situation is more complex since a type may contain any value as its component, deciding the equality of types entails doing reduction on values, which requires much more computation.

One common approach to deciding the equality of terms in dependent type theory, whenever the property of confluence holds, is \textit{normalization by evaluation} (NbE) \cite{berger1998normalization}, which reduces terms to the canonical representations for comparison. This method, however, does not scale to large theories for various reasons, among which:
\begin{itemize}
\item Producing the normal form may require more reduction steps than necessary. For example, in proving $(1 + 1) ^ {10} = 2 ^{(5 + 5)}$, it is easier if we can prove $1 + 1 == 2$ and $5 + 5 == 10$ instead of having to reduce both sides to 1024 using the definition of exponentiation.
\item As the number of definitions using previous definitions grows, the size of terms by expanding definitions can grow very quickly. For example, the inductive definition $x_n := (x_{n-1}, x_{n-1})$ makes the normal form of $x_{n}$ grow exponentially.
\end{itemize}
In this project, we shall focus on the first issue, that is, how to perform as few constant expansions as possible when deciding the convertibility of two terms in a dependently typed system. 

\subsubsection{Aim of the Project}
The first aim of the project is to study and explore a \emph{definition} mechanism, where definitions of constants could be expanded as few times as possible during the type checking process. What this means is that, we want to build a locking/unlocking operation on the constants, such that we can indicate certain constants to be locked (or unlocked) during the type checking process. We claim that a good definition mechanism can help improve the performance of a proof assistant that is based on dependent type theory. Without providing a rigorous proof, we will take the example above later to illustrate the idea behind the claim. Before that, we should at fist make it clearer for the reader this question: \emph{What exactly is the problem of definition and why is it important}?

A \emph{definition} in the context of dependent type theory is a term of the form $x : A = B$, meaning that $x$ is a constant of type $A$, defined as $B$. The problem with definition is not about how a constant should be introduced, but how it should be \textbf{evaluated}. \emph{Evaluation}, or \emph{reduction}, in dependent type theory has its concept rooted in \emph{$\lambda$-calculus} \cite{barendregt1984lambda} (with some variance we will come about later in section TODO). There, a term in the form $(\lambda x . M) \;N$ can be \textbf{evaluated} (or \textbf{reduced}) to the form $M[x := N]$, meaning that replacing the appearance of $x$ in $M$ with $N$ everywhere \footnote{There is a problem of the capture of free variables which we will not elaborate here. Curious and uninformed readers are encouraged to read detailed articles about \emph{$\lambda$-calculus.}}. In dependent type theory, however, different evaluation strategies can have huge difference when it comes to the efficiency of evaluation. 



For example, if we define the exponentiation function on natural numbers as
\begin{align*}
  exp &: Nat \to Nat \to Nat \\
  exp &\;\; \_\;\; 0 = 1 \\
  exp &\;\; n \;\; m = n * (exp \;\; n \;\; (m - 1))
\end{align*}
where $Nat$ represents type of natural number and $*$ is the definition of multiplication. Then when we try to prove the convertibility of two terms: $(1 + 1)^{10}$ and $2 ^ {(5+5)}$, instead of unfolding the definition of $exp$ multiple times, we keep the constant $exp$ \textbf{locked} and only reduce both sides to the term ($exp \;\; 2 \;\; 10$). Then by showing that they can be reduced to a common term, we prove their equality with much less computation. Here, a \textbf{locked} constant has only its type information exposed, such that a type checker can still use it to do as much type checking work as possible, whereas its definition is erased so that we can not do any function application on it.

The second aim of the project is to add a module system with the locking/unlocking capability. The module system is based on the idea `segments` borrowed from the work of AUTOMATH \cite{de1994survey}. (this paragraph could be expanded later when we have finished the module system)

\subsubsection{Limitations}
The limitations of our work come into three aspects: expressiveness, scope and meta-theory.
\begin{enumerate}
\item \textbf{Expressiveness:} We try to keep the syntax of our language as simple as possible in order to focus on the study of a proper definition mechanism, which inevitably affects the expressiveness of our language. As has been mentioned, there is no syntax for self-defined data types, nor for the pattern matches on case analysis functions. Besides, because we track the names of constants in a linear manner as an approach to the name collision problem, any constant declaration can not collide with that of top levels, there is no \emph{variable shadowing} in our language.
\item \textbf{Scope:} For the study of definition, we do not try to establish a universal mechanism that is applicable in different systems. What we present here is only \textbf{one} alternative for doing type checking in the presence of definitions in a dependent type theory. Thus, the result of our work applies only in a very limited scope.
\item \textbf{Meta-theory:} We do not present any meta-theory behind our system. Since our system shares much of its idea regardless of syntax or type checking rules with that of Mini-TT, there should be some correspondence between the meta-theories of these two systems, such as the property of the decidability of the type checking algorithm. But we will not conduct an analysis on this due to the limit of time and the limit of my knowledge. 
\end{enumerate}

\subsection{Theory}
Our system could be seen as an extension to \emph{$\lambda$-calculus} with definitions. In order for the reader to understand better the idea behind the choice of the syntax and semantics of our language, we need to first address some subtleties that differentiate our system from \emph{$\lambda$-calculus} and that back our choice for dealing with the names of the constants.

\subsubsection{Subtleties in a Dependent Type Theory}
We present the subtleties by giving the following examples. 

\begin{example}[Definitions in dependent type theory cannot be reduced to \emph{$\lambda$-calculus}] \label{exa1}
  Suppose we have
  \[ a : A, \;\;\; P : A \to U, \;\;\; f : P \; a \to P \; a \]
  then
  \[ \lambda (x : A) (y : P \; x) \; . \; f \; y \]
  is not well typed because the type of $y$ is ($P \; x$) not ($P \; a$). However, if we modify it to
  \[ \lambda (x : A = a) (y : P \; x) \; . \; f \; y \]
  then it is well typed. We see here that the definition of $x$ impacts the type safety of the whole term. This example shows that definitions in dependent type theory cannot be reduced to \emph{$\lambda$-calculus}.
\end{example}

\begin{example}[Names should be handled carefully] \label{exa2}
  Suppose we have
  \[ \lambda (x : Nat) (y : Nat = x) (x : Bool) \; . \; M \]
  In this term, the first declaration of $x$ is shadowed by the second one. Later when we do some computation on $M$, if we do not take the shadowing of the name of $x$ carefully, then the constant $y$ will become ill formed.
\end{example}

\begin{example}[Problem with capture of variables] \label{exa3}
  Suppose we have
  \begin{align*}
    x &: A \\
    y &: A \\
    b &: A \to A \to A \\
    u &: (A \to A \to A) \to (A \to A \to A) \\
    a &: (A \to A) \to (A \to A) \\
    z &: A \to A \to A
  \end{align*}
  Then the term below is well typed.
  \begin{equation} \label{eq-cap-var:1}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y)
  \end{equation}
  If we do the reduction on (\ref{eq-cap-var:1}) naively, we get
  \begin{align}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) ((\lambda z \; y \; x \; . \; a \; (z \; x) \; y) \; b) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) (\lambda y \; x \; . \; a \; (b \; x) \; y) & \implies \nonumber \\
    \lambda y \; x \; . \; a \; ((\lambda y \; x \; . \; a \; (b \; x) \; y)\; x) \; y \label{eq-cap-var:2}
  \end{align}
  At this point, we have a capture of variables problem.

  (\ref{eq-cap-var:2}) should be the same as
  \[ \lambda y \; x \; . \; a \; ((\lambda y \; x' \; . \; a \; (b \; x') \; y)\; x) \; y \]
  which reduces to
  \[ \lambda y \; x \; . \; a \; (\lambda x' \; . \; a \; (b \; x') \; x) \; y \]
  But if we do a naive reduction in (\ref{eq-cap-var:2}) without renaming, we get 
  \[ \lambda y \; x \; . \; a \; (\lambda x \; . \; a \; (b \; x) \; x) \; y \]
  which is not correct.

  This example shows another aspect of subtlety when dealing with names of variables in a dependent type theory.
\end{example}

\subsubsection{Definitions in a Dependent Type Theory}
The examples listed above provide us with insights about the common pitfalls one should avoid when implementing definitions in dependent type theory. From there, we derived the following principles that guide us through the pitfalls in our own implementation:

\begin{principle} \label{p1}
  For definitions in the form $x : A = B$, treat the type $A$ and the definition $B$ separately.
\end{principle}

\begin{principle} \label{p2}
  Forbid the shadowing of variable names.
\end{principle}

\begin{principle} \label{p3}
  Rename variable whenever necessary. 
\end{principle}

Principle \ref{p1} relates to example \ref{exa1}. As has been suggested in the example, the definition of a constant can be important to ensure the type safety of a term. In other cases, however, the definition is not needed, like in this term $\lambda (f : A \to B) (a : A) \; . \; f \; a$: $f$ could be any function from $A$ to $B$, $a$ could be any value of $A$, regardless of their specific values, we know for sure that term $f \; a$ has type $B$. These facts indicate that type and definition take unequal roles in dependent type theory: one can declare a constant without a definition, but cannot declare a constant without a type.

In our implementation, we use two constructs, $\rho$ and $\Gamma$, to keep track of the variables with their definitions (or values) and the variables with their types. We call $\rho$ the \emph{environment} and $\Gamma$ the \emph{context}. Essentially, they are list like structures that can be extended with declarations or a single expression acting as a value or type. We use $\rho$ to get the definition (or value) of a constant, $\Gamma$ for the type. We have an operation to convert a context $\Gamma$ to an environment $\rho$, but not the other way around. All the major operations (type checking, head reduction, etc.) exposed by our Haskell program are conducted under a top level context.

Principle \ref{p2} comes as a simple strategy to avoid the pitfall revealed by example \ref{exa2}. During the type checking process, each declaration, including the declarations from $\lambda$-abstraction, is checked with the top level context (actually, we have only one level context) to ensure no naming clash occurs. Using \emph{De Bruijn index} is another, maybe better, from the point of view of the user, way to avoid the name clashing issue. However, having to maintain the relationship between names and indices may unnecessarily complicate our implementation and obscure the main aim of the project. 

Principle \ref{p3} is less specific by using the phrase `whenever necessary`. Indeed, it is hard to generalize a rule that works in all conditions. The practice of variable renaming is dependent on the syntax of the language and its evaluation strategy. In our implementation, we rename variables in two situations: one is convertibility checking and the other is reading back a term to the normal form. We will give more details when we introduce these two operations in section TODO. 

Finally, we have a fourth, pillar principle in support of our locking/unlocking mechanism:

\begin{principle} \label{p4}
  Deferred evaluation.
\end{principle}

In order to reduce unnecessary reduction steps during the type checking process by exploiting a locking mechanism on variables, we need to defer the computation on function application as late as possible. We do this by
\begin{enumerate}
\item Using \emph{closure} to carry functions around. A closure is a function (or $\lambda$ abstraction) extended with an environment.
\item Applying $\beta$-reduction on multi-variable functions in an incremental manner.
\item Only unlocking a constant when the type checking procedure can not proceed. We use this technique to find the minimum set of unlocked constants to type check that a declaration is valid.
\end{enumerate}

With all the 4 principles introduced, we are ready to describe in detail the syntax and semantics of our language, and the operations we build upon it.

\subsubsection{Syntax of the Language}
A program of our language consists of a list of declarations. A declaration has either the form $x : A$ or $x : A = B$, where $A, B$ are expressions. A summary of the syntax can be found in table \ref{tab:syntax}.

\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    expression & $M,N,A,B$ & ::= & $U \mid x \mid M \; N \mid [D] M $ \\
    declaration & $D$ & ::= & $x : A \mid x : A = B$
  \end{tabular}
  \caption{Language Syntax}
  \label{tab:syntax}
\end{table}

The meaning of each expression constructor is explained as follows:
\begin{table}[h]
  \centering
  \begin{tabular}{c l l}
    $U$ & : & The type of small types. $U$ is also an element of itself \\
    $x$ & : & Variables with names, e.g. `x' , `y', `z' \\
    $M \; N$ & : & Function application \\
    $[D] M$ & : & Depending on the form of $D$, it has different meanings \\ 
  \end{tabular}
  \caption{Expressions}
\end{table}

An expression in the form $[x : A]\; M$ can be used to represent
\begin{itemize}
\item \textbf{Dependent Product:} $\Pi \,x : A \, . \, M$ - the type of functions which take an arbitrary object $x$ of type $A$ into an object of type $M$ ($M$ may dependent on $x$).
\item \textbf{$\lambda$-abstraction:} $\lambda\,(x : A) \; . \; M$ - a function that takes a variable $x$ of type $A$ into an expression $M$.
\end{itemize}

When $x$ does not appear in $M$ ($M$ does not depend on $x$), this expression is the same as $[\_ : A] M$. When used as a type of function, it means non-dependent functions of type $A \to M$, which we provide as a syntax sugar; When used as a $\lambda$ abstraction, it means the constant function $\lambda (\_:A) \; . \; M$ that always return $M$ regardless of the input argument.

An expression in the form $[x : A = B] M$ can be used to represent
\begin{itemize}
\item A \textit{let} clause: \textit{let $x : A = B$ in $M$}, or
\item A \textit{where} clause: \textit{$M$ where $x : A = B$}.
\end{itemize}

The syntax of our language is a substantial subset of that of Mini-TT. Moreover, we use the same syntax for both dependent product and $\lambda$ abstraction as an effort to maintain simplicity. This practice causes ambiguity only when an expression in the form $[x : A] M$ is viewed in isolation: it can be seen both as a dependent type and a function abstraction. In the former case, $M$ represents a type, whereas in the latter case a value. Our type checking rules ensure that it could be used in a consistent way.

\subsubsection{Operational Semantics}
\emph{Expressions} are evaluated to \emph{values} under a given environment. The definitions for \emph{values} are given in table \ref{tab:values}.

\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    values & $u, v$ & ::= & $U \mid x \mid u\, v \mid \langle [x : A] M, \rho \rangle $
  \end{tabular}
  \caption{Values of the Language}
  \label{tab:values}
\end{table}

The meaning of each value constructor is explained as follows:
\begin{table}[h]
  \centering
  \begin{tabular}{c l p{8cm}}
    $U$ & : & The value of \emph{Universe}, $U$ \\
    $x$ & : & \emph{Neutral value}, the value of a undefined variable \\
    $u \; v$ & : & Value of an application when the first value $u$ cannot be reduced to a closure \\
    $\langle [x : A] M, \rho \rangle$ & : & Closure, a function extended with an environment\\ 
  \end{tabular}
  \caption{Definition of Value}
\end{table}

Note that in our Haskell implementation, we use the same syntax for both expressions and values, since our syntax is simple.

An environment is defined as
\[
\rho ::= ()\,|\,\rho,\,x = v\,|\,\rho,\,x : A = B
\]
meaning that an environment is either empty, or another environment extended with a variable paired with its value, or extended with a definition. 

We give the semantics of our language by equations of the form $[\![M]\!]\rho = v$, meaning that the expression $M$ evaluates to the value $v$ in the environment $\rho$.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    $[\![U]\!]\rho$ & = & U \\
    $[\![x]\!]\rho$ & = & $\rho(x)$ \\
    $[\![M_1 \; M_2]\!]\rho$ & = & $\text{appVal} \; ([\![M_1]\!]\rho) \; ([\![M_2]\!]\rho)$ \\
    $[\![[x : A]\,B]\!]\rho$ & = & $\langle[x : A]\,B, \rho\rangle$ \\
    $[\![[x : A = B]\,M]\!]\rho$ & = & $[\![M]\!](\rho, x : A = B)$ 
  \end{tabular}
  \caption{Semantics of Language}
\end{table}

The operation \emph{appVal} is defined as:
\begin{align*}
  \text{appVal} \quad \langle [x : A]\,B, \rho \rangle \quad v \quad &= \quad [\![B]\!](\rho, x = v) \\
  \text{appVal} \quad v1 \quad v2 \quad &= \quad v1\;v2
\end{align*}

The lookup operation to find the value of a variable $x$ in $\rho$ is defined as
\begin{align*}
  ()(x) \quad &= \quad x \\
  (\rho, x = v)(x) \quad &= \quad v \\
  (\rho, y = v)(x) \quad &= \quad \rho(x)(y \neq x) \\
  (\rho, x : A = B)(x) \quad &= \quad [\![B]\!]\rho \\
  (\rho, y : A = B)(x) \quad &= \quad \rho(x)(y \neq x) \\
\end{align*}
Note that the type information in a definition is always discarded.

\subsubsection{Type Checking Rules}
\paragraph{Type Checking Context}
The type checking procedure is performed under a context $\Gamma$,
\[
  \Gamma ::= ()\,|\,\Gamma,\,x : A\,|\,\Gamma,\,x : A = B
\]
meaning that a type checking context is either empty, or another context extended with a variable paired with its type, or extended with a definition.

The lookup operation to find the type of a variable $x$ in $\Gamma$ is defined as
\begin{align*}
  ()(x) \quad &= \quad \text{error} \\
  (\Gamma, x : A)(x) \quad &= \quad A \\
  (\Gamma, y : A)(x) \quad &= \quad \Gamma(x)(y \neq x) \\
  (\Gamma, x : A = B)(x) \quad &= \quad A \\
  (\Gamma, y : A = B)(x) \quad &= \quad \Gamma(x)(y \neq x) 
\end{align*}
Note that the value information in a definition is always discarded.

In our implementation, when parsing the source file into the abstract syntax of our language, we make sure that each variable must be declared with a type and the name of the variable has never been used. By doing so, we ensure that the error condition in the lookup operation will never occur during the type checking process and each variable's name is unique.

We also defined a function named \emph{varsCont} that returns all the names of a context, and a function $freshVar$ that given a name of a variable and a list of used names, return a new name.
\begin{align*}
  varsCont &:: \Gamma \to [String] \\
  freshVar &:: String \to [String] \to String
\end{align*}
These two functions are used in the type checking process whenever a variable renaming is needed. We omit the implementation here since they are trivial and do not affect readers' understanding of the following text. 

The locking/unlocking mechanism in our system is implemented via a concept called \emph{lock strategy} plus a function called \emph{getEnv}. For a lock strategy $s$, we have 
\[ getEnv :: s \to \Gamma \to \rho \]

The idea is that when we lock a constant, we need to remove its definition from the environment $\rho$, such that when evaluated, this constant becomes a neutral value, cutting off all the possibility for further evaluation; When we unlock the constant later, we need to restore its definition to $\rho$. During the type checking process, the context $\Gamma$ is always extended with all the definitions declared so far. By the function \emph{getEnv} and a lock strategy $s$ that represents our intention about the locking/unlocking of each variable, we can conveniently get the environment $\rho$ that effectuates our locking strategy.

In our current implementation, we have 4 lock strategies: \emph{LockAll, LockNone, LockList vs, UnLockList vs}, where $vs$ is a list of variables. We give their definitions in a Haskell like pseudo-code in table \ref{tab:lock}.
\begin{table}[h] 
  \centering
  \begin{tabular}{l l l l p{5cm}}
    getEnv & LockAll  & $\Gamma$ & = & () \\
    \\ 
    getEnv & LockNone & () & = & ()        \\
    getEnv & LockNone & $\Gamma, x : A$ & = & getEnv LockNone $\Gamma$ \\ 
    getEnv & LockNone & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv LockNone $\Gamma$ \newline in $(\rho, x : A = B)$ \\
    \\ 
    getEnv & (LockList vs) & () & = & ()        \\
    getEnv & l@(LockList vs) & $\Gamma, x : A$ & = & getEnv l $\Gamma$ \\ 
    getEnv & l@(LockList vs) & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv l $\Gamma$ \newline in if $x \in vs$ then $\rho$ \newline else $(\rho, x : A = B)$\\
    \\
    getEnv & (UnLockList vs) & () & = & ()        \\
    getEnv & l@(UnLockList vs) & $\Gamma, x : A$ & = & getEnv l $\Gamma$ \\ 
    getEnv & l@(UnLockList vs) & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv l $\Gamma$ \newline in if $x \notin vs$ then $\rho$ \newline else $(\rho, x : A = B)$
  \end{tabular}
  \caption{Lock Strategies}
  \label{tab:lock}
\end{table}

During the type checking process, after a declaration is type checked, it is added to the underling type checking context. We denote the extension of a context by a declaration as
\begin{align*}
  \Gamma \vdash x : A &\Rightarrow \Gamma', \text{\emph{where}} \; \Gamma' = (\Gamma, x : A) \\
  \Gamma \vdash x : A = B &\Rightarrow \Gamma', \text{\emph{where}} \; \Gamma' = (\Gamma, x : A = B)
\end{align*}

Table \ref{tab:judgments} lists out the judgments used during the type checking process. There, $\Gamma$ is the type checking context and $s$ is the lock strategy. Note that the name collision check is performed before the type checking process, so we do not need to check the name uniqueness of each constant in the declarations anymore.
\begin{table}[h]
  \centering
  \begin{tabular}{l l p{2 in}}
    checkDecl   & $\Gamma,s \vdash D \Rightarrow \Gamma'$ & $D$ is a correct declaration and extends $\Gamma$ to $\Gamma'$ \\
    checkInferT & $\Gamma,s \vdash M \Rightarrow t$ & $M$ is a correct expression and its type is inferred to be $t$ \\
    checkWithT  & $\Gamma,s \vdash M \Leftarrow t$ & $M$ is a correct expression given type $t$ \\
    checkEqualInferT & $\Gamma,s \vdash u \equiv v \Rightarrow t $ & $u, v$ are convertible and their type is inferred to be $t$ \\ 
    checkEqualWithT  & $\Gamma,s \vdash u \equiv v \Leftarrow t  $ & $u, v$ are convertible given type $t$ 
  \end{tabular}
  \caption{Type Checking Judgments}
  \label{tab:judgments}
\end{table}

\paragraph{checkDecl}
\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \infer1{\Gamma,s \vdash x : A \Rightarrow \Gamma_1}
  \end{prooftree} \quad \quad
  \begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma,s \vdash B \Leftarrow t}
    \infer2{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
  \end{prooftree}\left(\begin{array}{l} t = \llbracket A \rrbracket \rho, \, \rho = \text{getEnv} \; s \; \Gamma\end{array}\right)
\]

For a declaration $x : A$, we check that $A$ is valid and has type $U$; For a definition $x : A = B$, we check further that $B$ has type $t$, which is the value of $A$ evaluated in the environment $\rho$, which we get first by applying function \emph{getEnv} to $s$ and $\Gamma$. 

\paragraph{checkInferT}
\[
  \begin{prooftree}
    \infer0{\Gamma,s \vdash U \Rightarrow U}
  \end{prooftree} \quad \quad
  \begin{prooftree}
    \infer0{\Gamma,s \vdash x \Rightarrow t}
  \end{prooftree}\left(\begin{array}{l} t = \llbracket A \rrbracket \rho, \, A = \Gamma(x) \\ \rho = \text{getEnv} \; s \; \Gamma\end{array}\right)
\]

$U$ has itself as its type; A variable $x$ is well typed and its type is inferred to be the value evaluated from its bound type in $\Gamma$.

\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash M \Rightarrow \langle [x : A] B, \rho \rangle}
    \hypo{\Gamma,s \vdash N \Leftarrow va}
    \infer2{\Gamma,s \vdash M \; N \Rightarrow v^*}
  \end{prooftree}\left(\begin{array}
                         {l} v^* = \llbracket B \rrbracket \rho_2, \, \rho_2 = (\rho, x = vn) \\
                         vn = \llbracket N \rrbracket \rho_1, \, \rho_1 = \text{getEnv} \; s \; \Gamma \\
                         va = \llbracket A \rrbracket \rho
                       \end{array}\right)
\]

For application $M \; N$, we do as follows
\begin{enumerate}
  \item Check $M$ is a function, namely, it has type in form $\langle [x : A] B, \rho \rangle$
  \item Check $N$ has the right type to be applied to $M$
  \item Return the value of $B$ evaluated in $\rho$ extended by binding $x$ to the value of $N$ 
\end{enumerate}

\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Rightarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Rightarrow t}
  \end{prooftree}
\]

For expression in the form of a \emph{let} clause $[x : A = B] \, M$, we first check the definition is correct, then infer the type of $M$ under the new context.

\paragraph{checkWithT}
\[
  \begin{prooftree}
    \infer0{\Gamma,s \vdash U \Leftarrow U}
  \end{prooftree} \quad \quad
  \begin{prooftree}
    \hypo{\Gamma,s \vdash v \equiv vt \Rightarrow v^*}
    \infer1{\Gamma,s \vdash x \Leftarrow v}
  \end{prooftree}\left(\begin{array}{l}
                         vt = \llbracket A \rrbracket \rho, \, A = \Gamma(x), \, \rho = \text{getEnv} \; s \; \Gamma
                       \end{array}\right)
\]

As we have already known, $U$ has $U$ as its type; To check a variable $x$ has type $v$, we first get the value $vt$ of the type bound to $x$ from the context $\Gamma$, then we check that $vt$ and $v$ are convertible.

\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash M \; N \Rightarrow v'}
    \hypo{\Gamma,s \vdash v' \equiv v \Rightarrow v^*}
    \infer2{\Gamma,s \vdash M \; N \Leftarrow v}
  \end{prooftree} \quad
  \begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma_1,s \vdash B \Leftarrow U}
    \infer2{\Gamma,s \vdash [x : A] \, B \Leftarrow U}
  \end{prooftree}(\Gamma_1 = (\Gamma, x : A))
\]

To check an application $M \; N$ has type $v$, we first infer its type $v'$, then we check that $v$ and $v'$ are convertible; To check an abstraction $[x : A] \, B$ has type $U$, we first check that $A$ has type $U$, then we check that $B$ also has type $U$ in an extended context.

\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma,s \vdash va \equiv va' \Rightarrow t}
    \hypo{\Gamma_1,s \vdash B \Leftarrow vb'}
    \infer3{\Gamma,s \vdash [x : A] \, B \Leftarrow \langle [x' : A'] \, B', \rho \rangle}
  \end{prooftree}\left(\begin{array}{l}
                         va = \llbracket A \rrbracket \rho_1, \, \rho_1 = \text{getEnv} \; s \; \Gamma \\
                         va' = \llbracket A' \rrbracket \rho \\
                         \rho_2 = (\rho, x' = x), \, vb' = \llbracket B' \rrbracket \rho_2 \\
                         \Gamma_1 = (\Gamma, x : A)
                       \end{array}\right)
\]

To check an abstraction $[x : A] \, B$ has a closure $\langle [x' : A'] \, B', \rho \rangle$ as its type, we do as follows
\begin{enumerate}
\item Check $A$ has type $U$
\item Evaluate the value of $A$ in the environment extracted from the current context, denote it as $va$
\item Evaluate the value of $A'$ in the environment from the closure, denote it as $va'$
\item Check that $va$ and $va'$ are convertible
\item Extend $\rho$ to $\rho_2$, with $x'$ bound to $x$
\item Evaluate $B'$ in $\rho_2$, denote the value as $vb'$
\item Extend $\Gamma$ to $\Gamma_1$, with $x$ having type $A$
\item Check $B$ has type $vb'$ in the new context $\Gamma_1$
\end{enumerate}
This is the rule used to check an abstraction has another abstraction as its type.

\[
  \begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Leftarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Leftarrow t}
  \end{prooftree}
\]

For an expression in the form of a \emph{let} clause $[x : A = B] \, M$, we first check the definition is correct, then check that $M$ has the required type under the new context.

\bibliographystyle{ieeetr}
\bibliography{report.bib}

\end{document}