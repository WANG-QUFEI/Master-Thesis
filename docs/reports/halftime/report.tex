\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{parskip}
\setlength{\parskip}{10pt}
\usepackage{array}
\usepackage{amsthm}
\usepackage{multirow}
\usepackage{ebproof}
\usepackage{stmaryrd}
\usepackage{titlesec}

\theoremstyle{remark}
\newtheorem{example}{Example}
\newtheorem{principle}{Principle}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\begin{document}
\title{Halftime Report}
\author{Qufei Wang}
\maketitle

\tableofcontents

\clearpage

\section{Report Structure}
This report will be structured into three parts: First, a brief summary of the current progress of the project, including what has been done, what remains to be done and the deviation from the planning report; Second, the time plan for the remaining work; Third, a draft of the final report. 

\section{Project Progress}
\subsection{What Has Been Done}
We have worked out a Haskell program that includes a type checker and a REPL interface which provides commands to experiment with the locking/unlocking mechanism. The first part of the project is to study how to present \emph{definitions} in a dependent type theory, where constants could be locked/unlocked during evaluation. For this part, we have finished most of the work.

\subsection{Remaining Work}
For the first part of the project, what remains is to study more about the theoretical background of \emph{definitions} in a proof system, particularly the theory about \emph{closure} and \emph{head-reduction}. This involves some literature study and an enhancement on the text in the draft of the final report that is related with the definition mechanism.

The second part of the project is to add a module mechanism with the notion of \emph{segment}. The idea of `segment' comes from the system AUTOMATH \cite{de1994survey} which is conceived and developed by N.G. de Bruijn. We illustrate the idea with the following example. 

\begin{example} \label{exm:seg}
  The idea of \emph{segment} is to have a new form of declaration: \[x = ds\; \texttt{Seg}\]
  where $x$ is the name of the segment and $ds$ a list of declaration. The word `Seg' is designed as a language keyword and a segment can also be seen as a module with parameters.

  Here is an example
  \[ s = [ A : *,\; id : A \to A = [x : A]\; x ]\; \texttt{Seg} \] 
  This is a module which contains a declaration and a definition. The declaration (\( A : * \footnote{`*' represents the type of small types}\)) is a parameter of the module and the definition $id$ is the identity function defined in this module.

  Suppose we have another type (\( A0 : * \)), then the expression \( (s \; A0) \; . \; id \) has $A0 \to A0$ as its type and closure $([x : A]\; x) (A = A0)$ as its value. 
\end{example}

For the module mechanism, what remains is to add the syntax to the language and the corresponding type checking rules to the type checker. A theoretical description of the implementation is also needed in the final report. 

\subsection{Deviation From The Time Plan}
This halftime report comes more than 20 days later than what has been scheduled in the planning report. The reasons for the delay are more of psychological than technical, of which the details will not be brought up here. Nonetheless, I have gradually come to comprehend more and appreciate the ideas behind this project, thus getting more motivated. Besides, the draft of the final report included here also provides the context and framework for the remaining work. These two facts together make me feel confident that the project could still be delivered as scheduled. For this, I would like to thank Thierry for his patience and support.

\subsection{Time Plan for The Remaining Work}
The planning report states that from June 28 to July 25, the coding work of the AUTOMATH system should be done. Before that, there should be 20 days time spent on reading and understanding the literature about AUTOMATH. Now it is no longer realistic to spend ample amount of time on reading before the coding work. Instead, as the example \ref{exm:seg} above suggests, a complete and deep understanding of AUTOMATH may not be a prerequisite to the implementation of the module mechanism.

So the time plan for the rest of the work remains the same: I will first try to have an implementation of the module system done before July 25. Then come back to the literature study and try to improve and complete the final report by the end of August.

\section{Draft of the Final Report}
\subsection{Abstract}
In this paper, we present a dependently typed language which is a simplified version of Mini-TT \cite{coquand2009simple}. The differences between our language and Mini-TT are threefold: First, the syntax of our language is much simpler than that of Mini-TT. Particularly, we use the same syntax for both dependent product ($\Pi x:A.B(x)$) and $\lambda$ abstraction ($\lambda x . M$); Second, we build a locking/unlocking mechanism to the system and find a method to calculate the minimum set of constants to be unlocked, such that a new constant could be type check valid; Third, as an extension to Mini-TT, we build a module system based on the notion of \emph{segments} borrowed from the system AUTOMATH \cite{de1994survey}.

The disadvantage of having a substantial limited syntax lies in its reduced capability in expressiveness: there is no syntax to create data types in our language, which could be expressed as \emph{Labeled Sum} in Mini-TT. However, starting out with a minimalized syntax allows us to focus more on the study of the definition mechanism, which is the main aim of this project. The outcome of the project is a REPL\footnote{REPL stands for a read-evaluate-print-loop program} implemented in Haskell, with commands to type check a source file and experiment with the locking/unlocking mechanism.

\subsection{Terminology}
In order to make clear of the potential ambiguity or unnecessary confusion over the words we choose to use in the following sections, we list below the terminology we use together with their meaning:
\begin{itemize}
  \item \textbf{Declaration:} A \emph{declaration} has either the form $x : A$ or $x : A = B$. The latter is also referred, rather frequently, as a \emph{definition}. Sometimes when we want to make a distinction between these two forms, we also use the word `declaration' specifically to indicate a term of the former form. 
  \item \textbf{Definition:} A \emph{definition} is a term of the form $x : A = B$, meaning that $x$ is an element of type $A$, defined as $B$. Sometimes, when we talk about the components of a specific definition, we also use the word `definition' specifically to indicate the part of term $B$.  
  \item \textbf{Constant:} A \emph{constant} is the name or identifier used in a declaration, like the $x$ in $x : A$, $x : A = B$.
  \item \textbf{Variable:} A synonym of the word \emph{constant}. More often, the word `variable' is used to refer to the variable bound in a $\lambda$-abstraction, like the variable $x$ in $\lambda x . A$. In most cases, these two words are interchangeable. 
  \item \textbf{Value:} When talk about the components of a definition $x : A = B$, we also use the word `value' to indicate the part of term $B$, meaning the value of $x$. However, in the semantics of our language, a `value' is more precisely used to refer to the result of expression evaluation.
\end{itemize}

\subsection{Introduction}
\subsubsection{Some Background About Dependent Types}
Dependent type theory has lent much of its power to the proof-assistant systems like Coq \cite{huet1997coq}, Lean \cite{de2015lean}, and functional programming languages like Agda \cite{norell2008dependently} and Idris \cite{brady2013idris}, and contributed much to their success. Essentially, \emph{dependent types} are types that depend on \textbf{values} of other types. As a simple example, consider the type that represents vectors of length $n$ comprising of elements of type $A$, which can be expressed as a dependent type ($\texttt{vec}\; A\; n$). Readers may easily recall that in imperative languages such as c or java, there are array types which depend on the type of their elements, but no types that depend on values of some other type. More formally, suppose we have defined a function which to an arbitrary object $x$ of type $A$ assigns a type $B(x)$, then the Cartesian product $(\Pi x \in A)B(x)$ is a type, namely the type of functions which take an arbitrary object $x$ of type $A$ into an object of type $B(x)$.

The advantage of having a strong typed system built into a language lies in the fact that well typed programs exclude a large portion of run-time errors than those without or with weak type systems. Just as the famous saying puts it “well-type programs cannot ‘go wrong’” [16]. It is in this sense that we say languages equipped with a dependently typed system are guaranteed with the highest level of correctness and precision, which makes them a natural option in building proof-assistant systems.

\subsubsection{Issues with Dependently Typed Systems}
The downside of introducing a dependent type system lies in its difficulties of implementation, one of which is checking the \textbf{convertibility} of terms. More precisely, in any typed system, it is crucial for the type checker to decide whether a type denoted by a term $A$ is equal with another type denoted by a term $B$. In a simple typed system, this is done by simply checking the syntactic identity of the symbols of the types. For example, in Java, a primitive type \emph{int} equals only to itself, nothing more. This is because types in Java are not computable \footnote{Technically speaking, the type of an object in Java can be retrieved by the Java \emph{reflection} mechanism and presented in the form of another object, thus subject to computation. Here, we stress on the fact that a type as a term is not computable on the syntactic level, e.g. being passed as an argument to a function.}: there's no way for other terms in the language to be reduced to the term \emph{int}. In a dependently typed system, however, the situation is more complex since a type may contain any value as its component, deciding the convertibility of types entails doing reduction on values, which requires much more computation.

One common approach to deciding the equality of terms in dependent type theory, whenever the property of confluence holds, is \textit{normalization by evaluation} (NbE) \cite{berger1998normalization}, which reduces terms to their canonical representation for comparison. This method, however, does not scale to large theories for various reasons, among which:
\begin{itemize}
\item Producing the normal form may require more reduction steps than necessary. For example, in proving $(1 + 1) ^ {10} = 2 ^{(5 + 5)}$, it is easier if we can prove $1 + 1 == 2$ and $5 + 5 == 10$ instead of having to reduce both sides to 1024 using the definition of exponentiation.
\item As the number of definitions using previous definitions grows, the size of terms by expanding definitions can grow very quickly. For example, the inductive definition $x_n := (x_{n-1}, x_{n-1})$ makes the normal form of $x_{n}$ grow exponentially.
\end{itemize}
In this project, we shall focus on the first issue, that is, how to perform as few constant expansions as possible when deciding the convertibility of two terms in a dependently typed system. 

\subsubsection{Aim of the Project}
The first aim of the project is to study how to present \emph{definitions} properly in the dependent type theory. We hope that the definitions of constants could be expanded as few times as possible during the type checking process. We claim that a good definition mechanism can help improve the performance of a proof assistant that is based on dependent type theory. We will analyze the example above later to give a support to our claim. Before that, we shall at fist make it clear for the reader this question: What exactly is the problem of definition and why is it important?

A \emph{definition} in the context of dependent type theory is a term of the form $x : A = B$, meaning that $x$ is a constant of type $A$, defined as $B$. The problem with definition is not about how a constant should be introduced, but how it should be \textbf{evaluated}. \emph{Evaluation}, or \emph{reduction}, in dependent type theory has its concept rooted in \emph{$\lambda$-calculus} \cite{barendregt1984lambda}. There, a term in the form $(\lambda x . M) \;N$ can be \textbf{evaluated} (or \textbf{reduced}) to the form $M[x := N]$, meaning that replacing the appearance of $x$ in $M$ with $N$ everywhere \footnote{There is a problem of the capture of free variables which we will not elaborate here. Curious and uninformed readers are encouraged to read detailed articles about \emph{$\lambda$-calculus.}}. In dependent type theory, however, different evaluation strategies can have huge difference when it comes to the efficiency of evaluation. 



For example, if we define the exponentiation function on natural numbers as
\begin{align*}
  exp &: Nat \to Nat \to Nat \\
  exp &\;\; \_\;\; 0 = 1 \\
  exp &\;\; n \;\; m = n * (exp \;\; n \;\; (m - 1))
\end{align*}
where $Nat$ represents type of natural number and $*$ is the definition of multiplication. Then when we try to prove the convertibility of two terms: $(1 + 1)^{10}$ and $2 ^ {(5+5)}$, instead of unfolding the definition of $exp$ multiple times, we keep the constant $exp$ \textbf{locked} and only reduce both sides to the term ($exp \;\; 2 \;\; 10$). Then by showing that they can be reduced to a common term, we prove their equality with much less computation. Here, a \textbf{locked} constant has only its type information exposed, such that a type checker can still use it to do as much type checking work as possible, whereas its definition is erased so that we can not do any function application on it.

The second aim of the project is to add a module system with the locking/unlocking capability. The module system is based on the idea `segments` borrowed from the work of AUTOMATH \cite{de1994survey}. (this paragraph could be expanded later when we have finished the module system)

\subsubsection{Limitations}
The limitations of our work come into three aspects: expressiveness, scope and meta-theory.
\begin{enumerate}
\item \textbf{Expressiveness:} We try to keep the syntax of our language as simple as possible in order to focus on the study of a proper definition mechanism, which inevitably affects the expressiveness of our language. As has been mentioned, there is no syntax for self-defined data types, nor for the pattern matches on case analysis functions. Besides, because we track the names of constants in a linear manner as an approach to the name collision problem, any constant declaration can not collide with that of top levels, there is no \emph{variable shadowing} in our language.
\item \textbf{Scope:} For the study of definition, we do not try to establish a universal mechanism that is applicable in different systems. What we present here is only \textbf{one} alternative for doing type checking in the presence of definitions in a dependent type theory. Thus, the result of our work applies only in a very limited scope.
\item \textbf{Meta-theory:} We do not present any meta-theory behind our system. Since our system shares much of its idea regardless of syntax or type checking rules with that of Mini-TT, there should be some correspondence between the meta-theories of these two systems, such as the property of the decidability of the type checking algorithm. But we will not conduct an analysis on this due to the limit of time and the limit of my knowledge. 
\end{enumerate}

\subsection{Theory}
Our system could be seen as an extension to \emph{$\lambda$-calculus} with definitions. In order for the reader to understand better the idea behind the choice of the syntax and semantics of our language, we need to first address some subtleties that differentiate our system from \emph{$\lambda$-calculus} and that back our choice for dealing with the names of the constants.

\subsubsection{Subtleties in a Dependent Type Theory}
We present the subtleties by giving the following examples. 

\begin{example}[Definitions in dependent type theory cannot be reduced to \emph{$\lambda$-calculus}] \label{exa1}
  Suppose we have
  \[ a : A, \;\;\; P : A \to U, \;\;\; f : P \; a \to P \; a \]
  then
  \[ \lambda (x : A) (y : P \; x) \; . \; f \; y \]
  is not well typed because the type of $y$ is ($P \; x$) not ($P \; a$). However, if we modify it to
  \[ \lambda (x : A = a) (y : P \; x) \; . \; f \; y \]
  then it is well typed. We see here that the definition of $x$ impacts the type safety of the whole term. This example shows that definitions in dependent type theory cannot be reduced to \emph{$\lambda$-calculus}.
\end{example}

\begin{example}[Names should be handled carefully] \label{exa2}
  Suppose we have
  \[ \lambda (x : Nat) (y : Nat = x) (x : Bool) \; . \; M \]
  In this term, the first declaration of $x$ is shadowed by the second one. Later when we do some computation on $M$, if we do not take the shadowing of the name of $x$ carefully, then the constant $y$ will become ill formed.
\end{example}

\begin{example}[Problem with capture of variables] \label{exa3}
  Suppose we have
  \begin{align*}
    x &: A \\
    y &: A \\
    b &: A \to A \to A \\
    u &: (A \to A \to A) \to (A \to A \to A) \\
    a &: (A \to A) \to (A \to A) \\
    z &: A \to A \to A
  \end{align*}
  Then the term below is well typed.
  \begin{equation} \label{eq-cap-var:1}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y)
  \end{equation}
  If we do the reduction on (\ref{eq-cap-var:1}) naively, we get
  \begin{align}
    (\lambda u \; . \; u \; (u \; b)) (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) ((\lambda z \; y \; x \; . \; a \; (z \; x) \; y) \; b) & \implies \nonumber \\
    (\lambda z \; y \; x \; . \; a \; (z \; x) \; y) (\lambda y \; x \; . \; a \; (b \; x) \; y) & \implies \nonumber \\
    \lambda y \; x \; . \; a \; ((\lambda y \; x \; . \; a \; (b \; x) \; y)\; x) \; y \label{eq-cap-var:2}
  \end{align}
  At this point, we have a capture of variables problem.

  (\ref{eq-cap-var:2}) should be the same as
  \[ \lambda y \; x \; . \; a \; ((\lambda y \; x' \; . \; a \; (b \; x') \; y)\; x) \; y \]
  which reduces to
  \[ \lambda y \; x \; . \; a \; (\lambda x' \; . \; a \; (b \; x') \; x) \; y \]
  But if we do a naive reduction in (\ref{eq-cap-var:2}) without renaming, we get 
  \[ \lambda y \; x \; . \; a \; (\lambda x \; . \; a \; (b \; x) \; x) \; y \]
  which is not correct.

  This example shows another aspect of subtlety when dealing with names of variables in a dependent type theory.
\end{example}

\subsubsection{Definitions in a Dependent Type Theory} \label{sec:theory:definition}
The examples listed above provide us with insights about the common pitfalls one should avoid when implementing definitions in dependent type theory. From there, we derived the following principles that guide us through the pitfalls in our own implementation:

\begin{principle} \label{p1}
  For definitions in the form $x : A = B$, treat the type $A$ and the definition $B$ separately.
\end{principle}

\begin{principle} \label{p2}
  Forbid the shadowing of variable names.
\end{principle}

\begin{principle} \label{p3}
  Rename variable whenever necessary. 
\end{principle}

Principle \ref{p1} relates to example \ref{exa1}. As has been suggested in the example, the definition of a constant can be important to ensure the type safety of a term. In other cases, however, the definition is not needed, like in this term $\lambda (f : A \to B) (a : A) \; . \; f \; a$: $f$ could be any function from $A$ to $B$, $a$ could be any value of $A$, regardless of their specific values, we know for sure that term $f \; a$ has type $B$. These facts indicate that type and definition take unequal roles in dependent type theory: one can declare a constant without a definition, but cannot declare a constant without a type.

In our implementation, we use two constructs, $\rho$ and $\Gamma$, to keep track of the variables with their definitions (or values) and the variables with their types. We call $\rho$ the \emph{environment} and $\Gamma$ the \emph{context}. Essentially, they are list like structures that can be extended with declarations or a single expression acting as a value or type. We use $\rho$ to get the definition (or value) of a constant, $\Gamma$ for the type. We have an operation to convert a context $\Gamma$ to an environment $\rho$, but not the other way around. All the major operations (type checking, head reduction, etc.) exposed by our Haskell program are conducted under a top level context.

Principle \ref{p2} comes as a simple strategy to avoid the pitfall revealed by example \ref{exa2}. During the type checking process, each declaration, including the declarations from $\lambda$-abstraction, is checked with the top level context (actually, we have only one level context) to ensure no naming clash occurs. Using \emph{De Bruijn index} is another, maybe better, from the point of view of the user, way to avoid the name clashing issue. However, having to maintain the relationship between names and indices may unnecessarily complicate our implementation and obscure the main aim of the project. 

Principle \ref{p3} is less specific by using the phrase `whenever necessary`. Indeed, it is hard to generalize a rule that works in all conditions. The practice of variable renaming is dependent on the syntax of the language and its evaluation strategy. In our implementation, we rename variables in two situations: one is convertibility checking and the other is reading back a term to the normal form.

Finally, we have a fourth, pillar principle in support of our locking/unlocking mechanism:
\begin{principle} \label{p4}
  Deferred evaluation.
\end{principle}

In order to reduce unnecessary reduction steps during the type checking process by exploiting a locking mechanism on variables, we need to defer the computation on function application as late as possible. We do this by
\begin{enumerate}
\item Using \emph{closure} to carry functions around. A closure is a function (or $\lambda$ abstraction) extended with an environment.
\item Applying $\beta$-reduction on multi-variable functions in an incremental manner.
\item Only unlocking a constant when the type checking procedure can not proceed. We use this technique to find the minimum set of unlocked constants to type check that a declaration is valid.
\end{enumerate}

With all the 4 principles introduced, we are ready to describe in detail the syntax and semantics of our language, and the operations we build upon it.

\subsubsection{Syntax of the Language}
A program of our language consists of a list of declarations. A declaration has either the form $x : A$ or $x : A = B$, where $A, B$ are expressions. A summary of the syntax can be found in table \ref{tab:syntax}.

\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    expression & $M,N,A,B$ & ::= & $U \mid x \mid M \; N \mid [D] M $ \\
    declaration & $D$ & ::= & $x : A \mid x : A = B$
  \end{tabular}
  \caption{Language Syntax}
  \label{tab:syntax}
\end{table}

The meaning of each expression constructor is explained as follows:
\begin{table}[h]
  \centering
  \begin{tabular}{c l l}
    $U$ & : & The type of small types. $U$ is also an element of itself \\
    $x$ & : & Variables with names, e.g. `x' , `y', `z' \\
    $M \; N$ & : & Function application \\
    $[D] M$ & : & Depending on the form of $D$, it has different meanings \\ 
  \end{tabular}
  \caption{Expressions}
\end{table}

An expression in the form $[x : A]\; M$ can be used to represent
\begin{itemize}
\item \textbf{Dependent Product:} $\Pi \,x : A \, . \, M$ - the type of functions which take an arbitrary object $x$ of type $A$ into an object of type $M$ ($M$ may dependent on $x$).
\item \textbf{$\lambda$-abstraction:} $\lambda\,(x : A) \; . \; M$ - a function that takes a variable $x$ of type $A$ into an expression $M$.
\end{itemize}

When $x$ does not appear in $M$ ($M$ does not depend on $x$), this expression is the same as $[\_ : A] M$. When used as a type of function, it means non-dependent functions of type $A \to M$, which we provide as a syntax sugar; When used as a $\lambda$ abstraction, it means the constant function $\lambda (\_:A) \; . \; M$ that always return $M$ regardless of the input argument.

An expression in the form $[x : A = B] M$ can be used to represent
\begin{itemize}
\item A \textit{let} clause: \textit{let $x : A = B$ in $M$}, or
\item A \textit{where} clause: \textit{$M$ where $x : A = B$}.
\end{itemize}

The syntax of our language is a substantial subset of that of Mini-TT. Moreover, we use the same syntax for both dependent product and $\lambda$ abstraction as an effort to maintain simplicity. This practice causes ambiguity only when an expression in the form $[x : A] M$ is viewed in isolation: it can be seen both as a dependent type and a function abstraction. In the former case, $M$ represents a type, whereas in the latter case a value. Our type checking rules ensure that it could be used in a consistent way.

\subsubsection{Operational Semantics}
\emph{Expressions} are evaluated to \emph{values} under a given environment. The definitions for \emph{values} are given in table \ref{tab:values}.

\begin{table}[h]
  \centering
  \begin{tabular}{l l l l}
    values & $u, v$ & ::= & $U \mid x \mid u\, v \mid \langle [x : A] M, \rho \rangle $
  \end{tabular}
  \caption{Values of the Language}
  \label{tab:values}
\end{table}

The meaning of each value constructor is explained as follows:
\begin{table}[h]
  \centering
  \begin{tabular}{c l p{8cm}}
    $U$ & : & The value of \emph{Universe}, $U$ \\
    $x$ & : & \emph{Neutral value}, the value of a undefined variable \\
    $u \; v$ & : & Value of an application when the first value $u$ cannot be reduced to a closure \\
    $\langle [x : A] M, \rho \rangle$ & : & Closure, a function extended with an environment\\ 
  \end{tabular}
  \caption{Definition of Value}
\end{table}

Note that in our Haskell implementation, we use the same syntax for both expressions and values, since our syntax is simple.

An environment is defined as
\[
\rho ::= ()\,|\,\rho,\,x = v\,|\,\rho,\,x : A = B
\]
meaning that an environment is either empty, or another environment extended with a variable paired with its value, or extended with a definition. 

We give the semantics of our language by equations of the form $[\![M]\!]\rho = v$, meaning that the expression $M$ evaluates to the value $v$ in the environment $\rho$.
\begin{table}[h]
  \centering
  \begin{tabular}{l l l}
    $[\![U]\!]\rho$ & = & U \\
    $[\![x]\!]\rho$ & = & $\rho(x)$ \\
    $[\![M_1 \; M_2]\!]\rho$ & = & $\text{appVal} \; ([\![M_1]\!]\rho) \; ([\![M_2]\!]\rho)$ \\
    $[\![[x : A]\,B]\!]\rho$ & = & $\langle[x : A]\,B, \rho\rangle$ \\
    $[\![[x : A = B]\,M]\!]\rho$ & = & $[\![M]\!](\rho, x : A = B)$ 
  \end{tabular}
  \caption{Semantics of Language}
\end{table}

The operation \emph{appVal} is defined as:
\begin{align*}
  &\text{appVal} \quad \langle [x : A]\,B, \rho \rangle \quad v \quad = \quad [\![B]\!](\rho, x = v) \\
  &\text{appVal} \quad v1 \quad v2 \quad \quad \quad \quad \quad = \quad v1\;v2
\end{align*}

The lookup operation to find the value of a variable $x$ in $\rho$ is defined as
\begin{align*}
  ()(x) \quad &= \quad x \\
  (\rho, x = v)(x) \quad &= \quad v \\
  (\rho, y = v)(x) \quad &= \quad \rho(x)(y \neq x) \\
  (\rho, x : A = B)(x) \quad &= \quad [\![B]\!]\rho \\
  (\rho, y : A = B)(x) \quad &= \quad \rho(x)(y \neq x) \\
\end{align*}
Note that the type information in a definition is always discarded.

\subsubsection{Type Checking Rules}
\paragraph{Type Checking Context}
The type checking procedure is performed under a context $\Gamma$,
\[
  \Gamma ::= ()\,|\,\Gamma,\,x : A\,|\,\Gamma,\,x : A = B
\]
meaning that a type checking context is either empty, or another context extended with a variable paired with its type, or extended with a definition.

The lookup operation to find the type of a variable $x$ in $\Gamma$ is defined as
\begin{align*}
  ()(x) \quad &= \quad \text{error} \\
  (\Gamma, x : A)(x) \quad &= \quad A \\
  (\Gamma, y : A)(x) \quad &= \quad \Gamma(x)(y \neq x) \\
  (\Gamma, x : A = B)(x) \quad &= \quad A \\
  (\Gamma, y : A = B)(x) \quad &= \quad \Gamma(x)(y \neq x) 
\end{align*}
Note that the value information in a definition is always discarded.

In our implementation, when parsing the source file into the abstract syntax of our language, we make sure that each variable must be declared with a type and the name of the variable has never been used. By doing so, we ensure that the error condition in the lookup operation will never occur during the type checking process and each variable's name is unique.

We also defined a function \texttt{freshVar} that given the name a variable and a type checking context, return a new name.
\begin{align*}
  \text{freshVar} &:: \text{String} \to \Gamma \to \text{String}
\end{align*}
This function is used whenever a variable renaming is needed. 

The locking/unlocking mechanism in our system is implemented via a concept called \emph{lock strategy} plus a function called \texttt{getEnv}. For a lock strategy $s$, we have 
\[ \text{getEnv} :: s \to \Gamma \to \rho \]

The idea is that when we lock a constant, we need to remove its definition from the environment $\rho$, such that when evaluated, this constant becomes a neutral value, cutting off all the possibility for further evaluation; When we unlock the constant later, we need to restore its definition to $\rho$. During the type checking process, the context $\Gamma$ is always extended with all the definitions declared so far. By the function \emph{getEnv} and a lock strategy $s$ that represents our intention about the locking/unlocking of each variable, we can conveniently get the environment $\rho$ that effectuates our locking strategy.

In our current implementation, we have 4 lock strategies: \emph{LockAll, LockNone, LockList vs, UnLockList vs}, where $vs$ is a list of variables. We give their definitions in a Haskell like pseudo-code in table \ref{tab:lock}.
\begin{table}[h] 
  \centering
  \begin{tabular}{l l l l p{5cm}}
    getEnv & LockAll  & $\Gamma$ & = & () \\
    \\ 
    getEnv & LockNone & () & = & ()        \\
    getEnv & LockNone & $\Gamma, x : A$ & = & getEnv LockNone $\Gamma$ \\ 
    getEnv & LockNone & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv LockNone $\Gamma$ \newline in $(\rho, x : A = B)$ \\
    \\ 
    getEnv & (LockList vs) & () & = & ()        \\
    getEnv & l@(LockList vs) & $\Gamma, x : A$ & = & getEnv l $\Gamma$ \\ 
    getEnv & l@(LockList vs) & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv l $\Gamma$ \newline in if $x \in vs$ then $\rho$ \newline else $(\rho, x : A = B)$\\
    \\
    getEnv & (UnLockList vs) & () & = & ()        \\
    getEnv & l@(UnLockList vs) & $\Gamma, x : A$ & = & getEnv l $\Gamma$ \\ 
    getEnv & l@(UnLockList vs) & $\Gamma, x : A = B$ & = & let $\rho$ = getEnv l $\Gamma$ \newline in if $x \notin vs$ then $\rho$ \newline else $(\rho, x : A = B)$
  \end{tabular}
  \caption{Lock Strategies}
  \label{tab:lock}
\end{table}

During the type checking process, after a declaration is type checked, it is added to the underling type checking context. We denote the extension of a context by a declaration as
\begin{align*}
  \Gamma \vdash x : A &\Rightarrow (\Gamma, x : A) \\
  \Gamma \vdash x : A = B &\Rightarrow (\Gamma, x : A = B)
\end{align*}

Table \ref{tab:judgments} lists out the judgments used during the type checking process. There, $\Gamma$ is the type checking context and $s$ is the lock strategy. Note that the name collision check is performed before the type checking process, so we do not need to check the name uniqueness of each constant in the declarations anymore.
\begin{table}[h]
  \centering
  \begin{tabular}{l l p{2 in}}
    checkDecl   & $\Gamma,s \vdash D \Rightarrow \Gamma'$ & $D$ is a correct declaration and extends $\Gamma$ to $\Gamma'$ \\
    checkInferT & $\Gamma,s \vdash M \Rightarrow t$ & $M$ is a correct expression and its type is inferred to be $t$ \\
    checkWithT  & $\Gamma,s \vdash M \Leftarrow t$ & $M$ is a correct expression given type $t$ \\
    checkEqualInferT & $\Gamma,s \vdash u \equiv v \Rightarrow t $ & $u, v$ are convertible and their type is inferred to be $t$ \\ 
    checkEqualWithT  & $\Gamma,s \vdash u \equiv v \Leftarrow t  $ & $u, v$ are convertible given type $t$ 
  \end{tabular}
  \caption{Type Checking Judgments}
  \label{tab:judgments}
\end{table}

\paragraph{checkDecl}
\begin{align}
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \infer1{\Gamma,s \vdash x : A \Rightarrow \Gamma_1}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma,s \vdash B \Leftarrow t}
    \infer2{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
  \end{prooftree}\left(\begin{array}{l l l}
                         t & = & \llbracket A \rrbracket \rho \\
                         \rho & = & \text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

For a declaration $x : A$, we check that $A$ is valid and has type $U$; For a definition $x : A = B$, we check further that $B$ has type $t$, which is the value of $A$ evaluated in the environment $\rho$, which we get first by applying function \texttt{getEnv} to $s$ and $\Gamma$. 

\paragraph{checkInferT}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \Rightarrow U}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash x \Rightarrow t}
  \end{prooftree}\left(\begin{array}{l l l}
                         t & = & \llbracket A \rrbracket \rho \\
                         A & = & \Gamma(x) \\
                         \rho & = & \text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

$U$ has itself as its type; A variable $x$ is well typed and its type is inferred to be the value evaluated from its bound type in $\Gamma$.

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash M \Rightarrow \langle [x : A] B, \rho \rangle}
    \hypo{\Gamma,s \vdash N \Leftarrow va}
    \infer2{\Gamma,s \vdash M \; N \Rightarrow v^*}
  \end{prooftree}\left(\begin{array}{l l l}
                         v^* & = & \llbracket B \rrbracket \rho_2\\
                         va & = & \llbracket A \rrbracket \rho \\
                         vn & = & \llbracket N \rrbracket \rho_1 \\
                         \rho_2 &= & (\rho, x = vn) \\
                         \rho_1 &= & \text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

For application $M \; N$, we do as follows
\begin{enumerate}
  \item Check $M$ is a function, namely, it has type in form $\langle [x : A] B, \rho \rangle$
  \item Check $N$ has the right type to be applied to $M$
  \item Return the value of $B$ evaluated in $\rho$ extended by binding $x$ to the value of $N$ 
\end{enumerate}

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Rightarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Rightarrow t}
  \end{prooftree}
\end{align}

For expression in the form of a \emph{let} clause $[x : A = B] \, M$, we first check the definition is correct, then infer the type of $M$ under the new context.

\paragraph{checkWithT}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \Leftarrow U}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash v \equiv vt \Rightarrow v^*}
    \infer1{\Gamma,s \vdash x \Leftarrow v}
  \end{prooftree}\left(\begin{array}{l l l}
                         vt &= & \llbracket A \rrbracket \rho \\
                         A &= & \Gamma(x) \\
                         \rho &= & \text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

As we have already known, $U$ has $U$ as its type; To check a variable $x$ has type $v$, we first get the value $vt$ of the type bound to $x$ from the context $\Gamma$, then we check that $vt$ and $v$ are convertible.

\begin{align}
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash M \; N \Rightarrow v'}
    \hypo{\Gamma,s \vdash v' \equiv v \Rightarrow v^*}
    \infer2{\Gamma,s \vdash M \; N \Leftarrow v}
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma_1,s \vdash B \Leftarrow U}
    \infer2{\Gamma,s \vdash [x : A] \, B \Leftarrow U}
  \end{prooftree}(\Gamma_1 = (\Gamma, x : A)) \label{rule:abs}
\end{align}

To check an application $M \; N$ has type $v$, we first infer its type $v'$, then we check that $v$ and $v'$ are convertible; To check an abstraction $[x : A] \, B$ has type $U$, we first check that $A$ has type $U$, then we check that $B$ also has type $U$ in an extended context.

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash A \Leftarrow U}
    \hypo{\Gamma,s \vdash va \equiv va' \Rightarrow t}
    \hypo{\Gamma_1,s \vdash B \Leftarrow vb'}
    \infer3{\Gamma,s \vdash [x : A] \, B \Leftarrow \langle [x' : A'] \, B', \rho \rangle}
  \end{prooftree}\left(\begin{array}{l l l}
                         va &= &\llbracket A \rrbracket \rho_1 \\
                         va' &= &\llbracket A' \rrbracket \rho \\
                         vb' &= &\llbracket B' \rrbracket \rho_2 \\
                         \Gamma_1 &= & (\Gamma, x : A) \\
                         \rho_1 &= &\text{getEnv}(s, \Gamma) \\
                         \rho_2 &= &(\rho, x' = x)
                       \end{array}\right)
\end{align}

To check an abstraction $[x : A] \, B$ has a closure $\langle [x' : A'] \, B', \rho \rangle$ as its type, we do as follows
\begin{enumerate}
\item Check $A$ has type $U$
\item Evaluate the value of $A$ in the environment extracted from the current context, denote it as $va$
\item Evaluate the value of $A'$ in the environment from the closure, denote it as $va'$
\item Check that $va$ and $va'$ are convertible
\item Extend $\rho$ to $\rho_2$, with $x'$ bound to $x$
\item Evaluate $B'$ in $\rho_2$, denote the value as $vb'$
\item Extend $\Gamma$ to $\Gamma_1$, with $x$ having type $A$
\item Check $B$ has type $vb'$ in the new context $\Gamma_1$
\end{enumerate}
This is the rule used to check an abstraction has another abstraction as its type.

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash x : A = B \Rightarrow \Gamma_1}
    \hypo{\Gamma_1,s \vdash M \Leftarrow t}
    \infer2{\Gamma,s \vdash [x : A = B]\,M \Leftarrow t}
  \end{prooftree}
\end{align}

For an expression in the form of a \emph{let} clause $[x : A = B] \, M$, we first check the definition is correct, then check that $M$ has the required type under the new context.

\paragraph{checkEqualInferT}
\begin{align}
  &\begin{prooftree}
    \infer0{\Gamma,s \vdash U \equiv U \Rightarrow U} 
  \end{prooftree} \\
  \nonumber \\
  &\begin{prooftree}
    \hypo{x =:= y}
    \infer1{\Gamma,s \vdash x \equiv y \Rightarrow v} 
  \end{prooftree}\left(\begin{array}{l l l}
                         v &= & \llbracket A \rrbracket \rho, \, A = \Gamma(x) \\
                         \rho &= &\text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

The first rule states that $U$ is equal to itself and has type $U$; For two variables to be equal, they must have the same name and their type is inferred to be the value of the type bound to the name in $\Gamma$.

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash M_1 \equiv M_2 \Rightarrow \langle [x : A] \, B, \rho \rangle}
    \hypo{\Gamma,s \vdash N_1 \equiv N_2 \Leftarrow va}
    \infer2{\Gamma,s \vdash (M_1 \; N_1) \equiv (M_2 \; N_2) \Rightarrow v} 
  \end{prooftree}\left(\begin{array}{l l l}
                         va &= &\llbracket A \rrbracket \rho \\
                         v &= &\llbracket B \rrbracket \rho_2 \\
                         vn &= &\llbracket N_1 \rrbracket \rho_1 \\ 
                         \rho_2 &= &(\rho, x = vn) \\
                         \rho_1 &= &\text{getEnv}(s, \Gamma)
                       \end{array}\right)
\end{align}

To check that two applications $M_1 \; N_1$ and $M_2 \; N_2$ are convertible and infer their type, we do as follows
\begin{enumerate}
  \item Check $M_1$ and $M_2$ are convertible and has type in the form of a closure $\langle [x : A] B, \rho \rangle$
  \item Get the value of $A$ evaluated in the environment $\rho$, denoted as $va$
  \item Check $N_1$ and $N_2$ are convertible given $va$ as their type.
  \item Get the value of $N_1$ evaluated in the environment extracted from the current type checking context, denoted as $vn$
  \item Extend $\rho$ with variable $x$ bound to $vn$ to $\rho_2$
  \item Return the value of $B$ evaluated in $\rho_2$ as the inferred type
\end{enumerate}

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Leftarrow U}
    \infer1{\Gamma,s \vdash \langle [x : A] \, B, \rho \rangle \equiv \langle [y : A'] \, B', \rho' \rangle \Rightarrow U} 
  \end{prooftree}
\end{align}

We check the convertibility of two closures by checking that they are convertible given type $U$. This inference rule is only used when two values representing \textbf{types} are checked for convertibility\footnote{Readers who are doubtful about this can check by going over the rules we present in this section.}. In this case, the abstractions from the closures are always seen as elements of the type $U$, not as elements of types in the form of some other closures. This reflects a `two-tier' type structure of our system: Only $U$ and elements of $U$ (in the form of an abstraction, as indicated by rule \ref{rule:abs}) are eligible to be used as types.

\paragraph{CheckEqualWithT}
\begin{align}
  \begin{prooftree}
    \hypo{\Gamma_1,s \vdash m \equiv n \Leftarrow vb}
    \infer1{\Gamma,s \vdash v1 \equiv v2 \Leftarrow \langle [x : A] \, B, \rho \rangle} 
  \end{prooftree}\left(\begin{array}{l l l}
                         y &= & \text{freshVar}(x, \Gamma) \\
                         \rho_1 &= & (\rho, x = y) \\
                         vb &= & \llbracket B \rrbracket \rho_1 \\ 
                         \rho_0 &= & \text{getEnv}(s, \Gamma) \\
                         m &= & \llbracket  v1 \; y \rrbracket \rho_0 \\
                         n &= & \llbracket v2 \; y \rrbracket \rho_0 \\
                         va &= & \llbracket A \rrbracket \rho \\
                         \Gamma_1 &= & (\Gamma, y : va)
                       \end{array}\right)
\end{align}

To check two values $v1$ and $v2$ are convertible and has type $\langle [x : A] \, B, \rho \rangle$, we do as follows
\begin{enumerate}
\item Generate a fresh variable $y$ from the context $\Gamma$
\item Extend $\rho$ to $\rho_1$ with $x$ bound to $y$ 
\item Get the value of $B$ evaluated in $\rho_1$, denote it as $vb$
\item Get the environment from the current context, denoted as $\rho_0$
\item Evaluate application ($v1 \; y$) in $\rho_0$, denote the result as $m$
\item Evaluate application ($v2 \; y$) in $\rho_0$, denote the result as $n$
\item Get the value of $A$ evaluated in $\rho$, denote it as $va$
\item Extend context $\Gamma$ to $\Gamma_1$ with the new variable $y$ typed with $va$
\item Check that $m$, $n$ are convertible in the context $\Gamma_1$ with $vb$ given as the type
\end{enumerate}

This rule accommodates for $\eta$-conversion, where $\lambda x . f \, x$ and $f$ can be checked convertible. This is the reason why we apply $v1$ and $v2$ with the new variable, and check the convertibility of the result. We generate a new variable and do variable renaming as a respect to principle \ref{p3} in section \ref{sec:theory:definition}. Note that we do not replace each $x$ in $B$ to $y$ manually, but add the binding $(x, y)$ to the environment in the closure and rely on the evaluation operation to achieve the desired effect.

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash va_1 \equiv va_2 \Leftarrow U}
    \hypo{\Gamma_1,s \vdash vb_1 \equiv vb_2 \Leftarrow U}
    \infer2{\Gamma,s \vdash \langle [x_1 : A_1] \, B_1, \rho_1 \rangle \equiv \langle [x_2 : A_2] \, B_2, \rho_2 \rangle \Leftarrow U} 
  \end{prooftree}\left(\begin{array}{l l l}
                         va_1 &= & \llbracket A_1 \rrbracket \rho_1 \\ 
                         va_2 &= & \llbracket A_2 \rrbracket \rho_2 \\ 
                         y &= & \text{freshVar}(x_1, \Gamma) \\
                         \rho_{21} &= & (\rho_1, x_1 = y) \\
                         \rho_{22} &= & (\rho_2, x_2 = y) \\
                         vb_1 &= & \llbracket B_1 \rrbracket \rho_{21} \\
                         vb_2 &= & \llbracket B_2 \rrbracket \rho_{22} \\
                         \Gamma_1 &= & (\Gamma, y : va_1)
                       \end{array}\right)
\end{align}

To check two closures are convertible and has type $U$, we do as follows
\begin{enumerate}
\item Get the value of $A_1$ evaluated in $\rho_1$, denoted as $va_1$
\item Get the value of $A_2$ evaluated in $\rho_2$, denoted as $va_2$
\item Check $va_1$ and $va_2$ are convertible given type $U$
\item Generate a fresh variable $y$ from the context $\Gamma$
\item Extend $\rho_1$ to $\rho_{21}$ with $x_1$ bound to $y$ 
\item Extend $\rho_2$ to $\rho_{22}$ with $x_2$ bound to $y$ 
\item Get the value of $B_1$ evaluated in $\rho_{21}$, denoted as $vb_1$
\item Get the value of $B_2$ evaluated in $\rho_{22}$, denoted as $vb_2$
\item Extend context $\Gamma$ to $\Gamma_1$ with the new variable $y$ typed with $va_1$
\item Check that $vb_1$, $vb_2$ are convertible in the context $\Gamma_1$ with $U$ given as the type
\end{enumerate}

\begin{align}
  \begin{prooftree}
    \hypo{\Gamma,s \vdash v1 \equiv v2 \Rightarrow t'}
    \hypo{\Gamma,s \vdash t \equiv t' \Rightarrow t^*}
    \infer2{\Gamma,s \vdash v1 \equiv v2 \Leftarrow t} 
  \end{prooftree}
\end{align}

To check that in the general case, $v1$ and $v2$ are convertible given type $t$, we first check $v1$ and $v2$ are convertible and infer their type as $t'$, then we check $t$ and $t'$ are convertible.

\subsubsection{Locking Mechanism}
As has been introduced, a locking mechanism in our system is realized by setting up a \emph{lock strategy}, and use it to extract an environment from the underlying type checking context. The \emph{environment} is the place where a variable is bound to its definition and the context in which the evaluation of an expression takes place. A variable without a value bound evaluates to itself, a \emph{neutral value} about which we know nothing, which cannot be reduced to any other form, either by itself or applied with another value. We adjust the lock strategy so that the definition of a constant could be erased or restored from the environment. In this way, we effectively lock/unlock a variable.

This is a locking mechanism applied to definitions where a constant acts as a \emph{locking unit}. The lock status of variables are independent of each other, meaning that lock/unlock a constant does not entail other constants in its definition being locked/unlocked. An alternative is to apply locking on expressions, where we define a metric of computation such that during evaluation, only certain `steps' of reductions are performed. We did not build this alternative in our system but will elaborate the idea more in section \ref{sec:head-red} when we talk about \emph{head reduction}.

One application of our locking mechanism is to find the minimum set of constants unfolded in a well typed context, such that another constant could be checked valid. The method is straightforward and largely based on the type checking inference rules. We only sketch the idea here, readers who are curious can refer to appendix \ref{apdix:source-code} for a complete view of the Haskell source code.

Say we have a text file which contains a valid program (a list of declarations) of our language. We want to find the minimum set of constants unfolded for another constant, say $x$, to be valid. We do as follows:
\begin{enumerate}
\item Load and type check the program with no variables locked. This will give us the complete type checking context $\Gamma^*$ .
\item Find the definition of $x$ in $\Gamma*$, denote it as $D$.
\item Denote the context consisting of all the declarations which appear before $D$ as $\Gamma$.
\item Create a list \texttt{vs} that is used to keep track of all the variables unfolded and change the lock strategy to \texttt{UnLockList vs}. The initial value of \texttt{vs} is \texttt{[]} and the initial lock strategy is actually \texttt{LockAll}.
\item Type check the declaration $D$. Whenever the type checking process halts because of an unmatched pattern (e.g. checking $[x : A] \, B$ with a neutral value $x$) or fails because of a violation to one of the inference rules, find the first variable locked that causes the exception, add it to \texttt{vs} and update the lock strategy.
\item Repeat 5 until the type checking process succeed.
\item Return the intersection of the variables in \texttt{vs} and the variables in $\Gamma$ as the result.
\end{enumerate}

Note that because the program is well typed, this algorithm is guaranteed to terminate. We take the intersection in the final step because the renaming operation introduces new variables that are not originally declared.

\subsubsection{Read Back to Normal Form}

\subsubsection{Head Reduction} \label{sec:head-red}

\subsection{Methods}

\subsection{Results}

\subsection{Conclusion}


\clearpage

\bibliographystyle{ieeetr}
\bibliography{report.bib}

\appendix
\section{Appendix} 
\subsection{Haskell Source Code} \label{apdix:source-code}

\end{document}